"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/await-lock";
exports.ids = ["vendor-chunks/await-lock"];
exports.modules = {

/***/ "(ssr)/./node_modules/await-lock/build/AwaitLock.js":
/*!****************************************************!*\
  !*** ./node_modules/await-lock/build/AwaitLock.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _AwaitLock_acquired, _AwaitLock_waitingResolvers;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * A mutex lock for coordination across async functions\n */\nclass AwaitLock {\n    constructor() {\n        _AwaitLock_acquired.set(this, false);\n        _AwaitLock_waitingResolvers.set(this, new Set());\n    }\n    /**\n     * Whether the lock is currently acquired or not. Accessing this property does not affect the\n     * status of the lock.\n     */\n    get acquired() {\n        return __classPrivateFieldGet(this, _AwaitLock_acquired, \"f\");\n    }\n    /**\n     * Acquires the lock, waiting if necessary for it to become free if it is already locked. The\n     * returned promise is fulfilled once the lock is acquired.\n     *\n     * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before\n     * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid\n     * timeout values depends on how `setTimeout` handles those values.\n     *\n     * After acquiring the lock, you **must** call `release` when you are done with it.\n     */\n    acquireAsync({ timeout } = {}) {\n        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n            __classPrivateFieldSet(this, _AwaitLock_acquired, true, \"f\");\n            return Promise.resolve();\n        }\n        if (timeout == null) {\n            return new Promise((resolve) => {\n                __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").add(resolve);\n            });\n        }\n        let resolver;\n        let timer;\n        return Promise.race([\n            new Promise((resolve) => {\n                resolver = () => {\n                    clearTimeout(timer);\n                    resolve();\n                };\n                __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").add(resolver);\n            }),\n            new Promise((_, reject) => {\n                timer = setTimeout(() => {\n                    __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").delete(resolver);\n                    reject(new Error(`Timed out waiting for lock`));\n                }, timeout);\n            }),\n        ]);\n    }\n    /**\n     * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns\n     * `true` if the lock was free and is now acquired, and `false` otherwise.\n     *\n     * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs\n     * synchronously without waiting for the JavaScript task queue.\n     */\n    tryAcquire() {\n        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n            __classPrivateFieldSet(this, _AwaitLock_acquired, true, \"f\");\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer\n     * must release the lock exactly once.\n     */\n    release() {\n        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, \"f\")) {\n            throw new Error(`Cannot release an unacquired lock`);\n        }\n        if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").size > 0) {\n            // Sets preserve insertion order like a queue\n            const [resolve] = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\");\n            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, \"f\").delete(resolve);\n            resolve();\n        }\n        else {\n            __classPrivateFieldSet(this, _AwaitLock_acquired, false, \"f\");\n        }\n    }\n}\nexports[\"default\"] = AwaitLock;\n_AwaitLock_acquired = new WeakMap(), _AwaitLock_waitingResolvers = new WeakMap();\n//# sourceMappingURL=AwaitLock.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdhaXQtbG9jay9idWlsZC9Bd2FpdExvY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxJQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGVhY2Utem9uZS13ZWIvLi9ub2RlX21vZHVsZXMvYXdhaXQtbG9jay9idWlsZC9Bd2FpdExvY2suanM/NDVkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfQXdhaXRMb2NrX2FjcXVpcmVkLCBfQXdhaXRMb2NrX3dhaXRpbmdSZXNvbHZlcnM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgbXV0ZXggbG9jayBmb3IgY29vcmRpbmF0aW9uIGFjcm9zcyBhc3luYyBmdW5jdGlvbnNcbiAqL1xuY2xhc3MgQXdhaXRMb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgX0F3YWl0TG9ja19hY3F1aXJlZC5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICBfQXdhaXRMb2NrX3dhaXRpbmdSZXNvbHZlcnMuc2V0KHRoaXMsIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGxvY2sgaXMgY3VycmVudGx5IGFjcXVpcmVkIG9yIG5vdC4gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgZG9lcyBub3QgYWZmZWN0IHRoZVxuICAgICAqIHN0YXR1cyBvZiB0aGUgbG9jay5cbiAgICAgKi9cbiAgICBnZXQgYWNxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bd2FpdExvY2tfYWNxdWlyZWQsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgdGhlIGxvY2ssIHdhaXRpbmcgaWYgbmVjZXNzYXJ5IGZvciBpdCB0byBiZWNvbWUgZnJlZSBpZiBpdCBpcyBhbHJlYWR5IGxvY2tlZC4gVGhlXG4gICAgICogcmV0dXJuZWQgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAgICAgKlxuICAgICAqIEEgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKSBtYXkgYmUgb3B0aW9uYWxseSBwcm92aWRlZC4gSWYgdGhlIGxvY2sgY2Fubm90IGJlIGFjcXVpcmVkIGJlZm9yZVxuICAgICAqIHRoZSB0aW1lb3V0IGVsYXBzZXMsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuIFRoZSBiZWhhdmlvciBvZiBpbnZhbGlkXG4gICAgICogdGltZW91dCB2YWx1ZXMgZGVwZW5kcyBvbiBob3cgYHNldFRpbWVvdXRgIGhhbmRsZXMgdGhvc2UgdmFsdWVzLlxuICAgICAqXG4gICAgICogQWZ0ZXIgYWNxdWlyaW5nIHRoZSBsb2NrLCB5b3UgKiptdXN0KiogY2FsbCBgcmVsZWFzZWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCBpdC5cbiAgICAgKi9cbiAgICBhY3F1aXJlQXN5bmMoeyB0aW1lb3V0IH0gPSB7fSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F3YWl0TG9ja19hY3F1aXJlZCwgXCJmXCIpKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Bd2FpdExvY2tfYWNxdWlyZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bd2FpdExvY2tfd2FpdGluZ1Jlc29sdmVycywgXCJmXCIpLmFkZChyZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNvbHZlcjtcbiAgICAgICAgbGV0IHRpbWVyO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F3YWl0TG9ja193YWl0aW5nUmVzb2x2ZXJzLCBcImZcIikuYWRkKHJlc29sdmVyKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F3YWl0TG9ja193YWl0aW5nUmVzb2x2ZXJzLCBcImZcIikuZGVsZXRlKHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZWQgb3V0IHdhaXRpbmcgZm9yIGxvY2tgKSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmVzIHRoZSBsb2NrIGlmIGl0IGlzIGZyZWUgYW5kIG90aGVyd2lzZSByZXR1cm5zIGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZy4gUmV0dXJuc1xuICAgICAqIGB0cnVlYCBpZiB0aGUgbG9jayB3YXMgZnJlZSBhbmQgaXMgbm93IGFjcXVpcmVkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gY2FsbGluZyBgYWNxdWlyZUFzeW5jYCB3aXRoIGEgemVyby1taWxsaXNlY29uZCB0aW1lb3V0IGluIHRoYXQgaXQgcnVuc1xuICAgICAqIHN5bmNocm9ub3VzbHkgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgSmF2YVNjcmlwdCB0YXNrIHF1ZXVlLlxuICAgICAqL1xuICAgIHRyeUFjcXVpcmUoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXdhaXRMb2NrX2FjcXVpcmVkLCBcImZcIikpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0F3YWl0TG9ja19hY3F1aXJlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlcyB0aGUgbG9jayBhbmQgZ2l2ZXMgaXQgdG8gdGhlIG5leHQgd2FpdGluZyBhY3F1aXJlciwgaWYgdGhlcmUgaXMgb25lLiBFYWNoIGFjcXVpcmVyXG4gICAgICogbXVzdCByZWxlYXNlIHRoZSBsb2NrIGV4YWN0bHkgb25jZS5cbiAgICAgKi9cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F3YWl0TG9ja19hY3F1aXJlZCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWxlYXNlIGFuIHVuYWNxdWlyZWQgbG9ja2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bd2FpdExvY2tfd2FpdGluZ1Jlc29sdmVycywgXCJmXCIpLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAvLyBTZXRzIHByZXNlcnZlIGluc2VydGlvbiBvcmRlciBsaWtlIGEgcXVldWVcbiAgICAgICAgICAgIGNvbnN0IFtyZXNvbHZlXSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F3YWl0TG9ja193YWl0aW5nUmVzb2x2ZXJzLCBcImZcIik7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Bd2FpdExvY2tfd2FpdGluZ1Jlc29sdmVycywgXCJmXCIpLmRlbGV0ZShyZXNvbHZlKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0F3YWl0TG9ja19hY3F1aXJlZCwgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEF3YWl0TG9jaztcbl9Bd2FpdExvY2tfYWNxdWlyZWQgPSBuZXcgV2Vha01hcCgpLCBfQXdhaXRMb2NrX3dhaXRpbmdSZXNvbHZlcnMgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXdhaXRMb2NrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/await-lock/build/AwaitLock.js\n");

/***/ })

};
;